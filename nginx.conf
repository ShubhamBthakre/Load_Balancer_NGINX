events {}

http {

    # Round Robin Load Balancing Method
#    upstream erp_backend {
#     server host.docker.internal:3001 max_fails=2 fail_timeout=10s;
#     server host.docker.internal:3002 max_fails=2 fail_timeout=10s;
#     server host.docker.internal:3003 max_fails=2 fail_timeout=10s;
# }


  # Weighted Round Robin
        # 3001 will receive more traffic than others
    upstream erp_backend {
      
        server host.docker.internal:3001 weight=3;
        server host.docker.internal:3002 weight=1;
        server host.docker.internal:3003 weight=1;
    }


# ğŸ”„ Apply the Config

# After updating nginx.conf:

# docker restart erp-nginx

    server {
        listen 80;

        location / {
            proxy_pass http://erp_backend;
        }
    }
}




# ğŸš€ NGINX â€“ Quick Notes
# ğŸ”¹ What is NGINX?

# High-performance web server, reverse proxy, and load balancer

# Commonly used in front of backend services

# Handles high traffic with low memory usage

# ğŸ”¹ Why NGINX is Used

# Distributes traffic across multiple servers

# Improves availability, performance, and scalability

# Acts as a single entry point for FE & BE

# ğŸ”¹ Core NGINX Concepts

# Worker-based, event-driven architecture

# Non-blocking I/O â†’ very fast

# Configuration-based (no code changes)

# ğŸ”¹ Main Configuration Blocks

# events {} â†’ connection handling

# http {} â†’ HTTP-related config

# server {} â†’ virtual server (host + port)

# location {} â†’ request routing rules

# ğŸ”¹ Reverse Proxy

# NGINX sits between client and backend

# Client never talks directly to backend

# Backend IPs/ports are hidden

# ğŸ”¹ Load Balancing (Upstream)

# upstream defines backend servers

# Default algorithm â†’ Round Robin

# All backend instances must expose same APIs

# ğŸ”¹ Load Balancing Algorithms

# Round Robin â†’ default, equal distribution

# Weighted Round Robin â†’ controlled traffic

# Least Connections â†’ least busy server

# IP Hash â†’ sticky sessions

# ğŸ”¹ Failover Handling

# Automatically removes unhealthy servers

# max_fails â†’ number of failed attempts

# fail_timeout â†’ temporary removal duration

# Ensures high availability

# ğŸ”¹ Health Check Types

# Passive (default): detects failure on request

# Active (NGINX Plus): periodic health checks

# ğŸ”¹ Frontend + Backend Setup

# Serve FE static files via NGINX

# Proxy API calls to backend using /api

# Single domain, no CORS issues

# ğŸ”¹ Common Directives

# proxy_pass â†’ forward requests

# proxy_set_header â†’ pass headers

# try_files â†’ SPA routing support

# expires â†’ browser caching

# gzip â†’ response compression

# ğŸ”¹ Docker + NGINX

# Run NGINX without installing locally

# Use volume mounts to inject config

# Easy to start, stop, and reset

# ğŸ”¹ Key Ports Concept

# Host port â†’ exposed to browser

# Container port â†’ internal service port

# Example: 8080:80

# ğŸ”¹ Best Practices

# Backend services should be stateless

# All instances must be identical

# Use relative API paths (/api)

# Keep FE unaware of backend scaling

# ğŸ”¹ Common Use Cases

# API Gateway

# Load Balancer

# Reverse Proxy

# Static file hosting

# Rate limiting & security

# ğŸ”¹ One-Line Explanation (Interview Ready)

# â€œNGINX is a high-performance reverse proxy and load balancer used to distribute traffic, improve availability, and act as a single entry point for applications.â€



# 1ï¸âƒ£ Reverse Proxy
# ğŸ”¹ What it is

# A server that sits in front of backend servers

# Client talks to proxy, never directly to backend

# ğŸ”¹ What it does

# Forwards requests to backend

# Hides backend details (IP, ports)

# Can serve frontend + backend together

# ğŸ”¹ Example
# location /api {
#     proxy_pass http://backend;
# }

# ğŸ”¹ Use cases

# Serve FE & BE from one domain

# Hide internal services

# Basic routing

# ğŸ”¹ Think of it as

# A receptionist who forwards you to the correct room

# 2ï¸âƒ£ Load Balancer
# ğŸ”¹ What it is

# A specialized reverse proxy

# Distributes traffic across multiple backend instances

# ğŸ”¹ What it does

# Round robin

# Weighted routing

# Failover handling

# High availability

# ğŸ”¹ Example
# upstream erp_backend {
#     server 3001;
#     server 3002;
#     server 3003;
# }

# ğŸ”¹ Use cases

# Scale backend horizontally

# Prevent overload

# Zero downtime

# ğŸ”¹ Think of it as

# A traffic police officer redirecting cars to less crowded roads

# 3ï¸âƒ£ API Gateway
# ğŸ”¹ What it is

# A full-featured entry point for APIs

# Used heavily in microservices

# ğŸ”¹ What it does (IMPORTANT)

# Authentication & authorization

# Rate limiting

# Request validation

# API versioning

# Logging & monitoring

# Routing to multiple services

# ğŸ”¹ Example
# /api/auth â†’ Auth Service
# /api/orders â†’ Order Service
# /api/users â†’ User Service

# ğŸ”¹ Use cases

# Microservices architecture

# Centralized API control

# Security enforcement

# ğŸ”¹ Think of it as

# Airport security + immigration + traffic control